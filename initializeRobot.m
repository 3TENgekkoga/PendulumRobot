function  [Ts, T_filt, r, ref, x0, A, B, C, D, K, P0, Q, R, N] = initializeRobot()
    % ====== 倒立ロボットの物理パラメータ設定 ==================================
    g  = 9.8;    % 重力加速度[m/sec^2]
    b  = 0.7;    % 摩擦係数
    L  = 0.12;   % 車高[m]
    r  = 0.034;  % タイヤ半径[m]
    Mc = 0.1020; % タイヤ部重量[kg]
    Mp = 0.72;   % 倒立部重量[kg]
    Jp = 0.0042; % 倒立部慣性モーメント[kg*m^2]

    Ts = 0.01;     % マイコンのサンプリング周期[sec]
    T_filt = 0.01; % センサのローパスカットオフ周期[sec]

    % ====== 目標値 ===========================================================
    ref = [0; 0; -(pi/180)*4; 0];

    % ====== 状態空間表現 =====================================================
    % 状態方程式：X_dot = AX + Bu
    % 状態変数  ：X = [x; x_dot; alpha; alpha_dot]
    % x        ：変位[m]
    % x_dot    ：速度[m/sec]
    % alpha    ：姿勢角度[rad]
    % alpha_dot：姿勢角速度[rad/sec]
    
    x0 = [0; 0; (pi/180)*10; 0];  % 初期状態

    a_11 = -b/(Mp+Mc-((Mp*L)^2)/(Jp+Mp*L^2));
    a_13 = -(g*(Mp*L)^2)/((Mp+Mc)*(Jp+Mp*L^2)-(Mp*L)^2);
    a_41 = Mp*L*b/((Mp+Mc)*(Jp+Mp*L^2)-(Mp*L)^2);
    a_43 = -(Mp*g*L^2)/((Mp+Mc)*(Jp+Mp*L^2)-(Mp*L)^2);

    b_1  = 1/(Mp+Mc-((Mp*L)^2)/(Jp+Mp*L^2));
    b_4  = -Mp*L/((Mp+Mc)*(Jp+Mp*L^2)-(Mp*L)^2);

    A = [0 1 0 0; 0 a_11 a_13 0; 0 0 0 1; 0 a_41 a_43 0];
    B = [0; b_1; 0; b_4];

    % eigA = eig(A)     % 安定性判別

    % % 可制御性判定
    % Co = [B A*B A*A*B A*A*A*B]
    % rankCo = rank(Co) % rankCo = 4 ならば可制御

    % 観測方程式：y = CX + Du
    C = [1 0 0 0; 0 1 0 0; 0 0 1 0; 0 0 0 1];
    D = [0; 0; 0; 0];

    % % 可観測性判定
    % Uo = [C; C*A; C*A*A; C*A*A*A]
    % rankUo = rank(Uo) % rankUo = 4 ならば可観測

    % ====== 制御パラメータ設定 ===============================================
    % 極配置法
    p = [-110+110i, -110-110i, -120, -130]; % 状態フィードバック制御系の極配置
    e = [exp(p(1)*Ts) exp(p(2)*Ts) exp(p(3)*Ts) exp(p(4)*Ts)];
    K = place(A,B,e);
    
    % LOR法
    % Wx = diag([1, 10000, 10000, 5000])./Ts; % 状態に対する重み
    % Wu = 1*Ts; % 入力に対する重み
    % K = dlqr(A, B, Wx, Wu); % LQRによる最適ゲインの計算

    % ====== カルマンフィルタ設定 =============================================
    % 推定状態の初期共分散 P0：
    P0 = diag([0, 0, 0, 0]);

    % プロセス雑音共分散行列 GQG：
    q1 = @(t) (b_1 + b_4)^2;
    q2 = @(t) (b_1*exp(a_11*t) + b_4)^2;
    q3 = @(t) (b_1 + b_4*exp(t))^2;
    q4 = @(t) (b_1*exp(a_41*t) + b_4)^2;

    int_q1 = integral(q1, 0, Ts, 'ArrayValued', true);
    int_q2 = integral(q2, 0, Ts, 'ArrayValued', true);
    int_q3 = integral(q3, 0, Ts, 'ArrayValued', true);
    int_q4 = integral(q4, 0, Ts, 'ArrayValued', true);

    % 有限可到達性グラミアンから導出したプロセス雑音
    gainQ = 0.01;    
    Q = gainQ*[int_q1 0 0 0; 0 int_q2 0 0; 0 0 int_q3 0; 0 0 0 int_q4];
    
    % 観測雑音共分散行列 R：    
    r1 = (r*13.85*pi/180)^2;
    r2 = (r*2*pi*36/(60*30))^2;
    r3 = 0.0022;
    r4 = 0.0001;
    
    % センサ特性から導出した観測雑音
    R = [r1 0 0 0; 0 r2 0 0; 0 0 r3 0; 0 0 0 r4];

    % プロセスおよび測定ノイズの相互共分散行列
    N = [0 0 0 0; 0 0 0 0; 0 0 0 0; 0 0 0 0]; 
    % ========================================================================
end